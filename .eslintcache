[{"/Users/evgeny/group-calls-animation/src/index.js":"1","/Users/evgeny/group-calls-animation/src/App.js":"2","/Users/evgeny/group-calls-animation/src/reportWebVitals.js":"3","/Users/evgeny/group-calls-animation/src/LineBlobDrawable.js":"4","/Users/evgeny/group-calls-animation/src/TopBar.js":"5","/Users/evgeny/group-calls-animation/src/Button.js":"6","/Users/evgeny/group-calls-animation/src/BlobDrawable.js":"7"},{"size":500,"mtime":1610671041315,"results":"8","hashOfConfig":"9"},{"size":4849,"mtime":1611668434994,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1610671041316,"results":"11","hashOfConfig":"9"},{"size":3426,"mtime":1611585624505,"results":"12","hashOfConfig":"9"},{"size":9347,"mtime":1611883147367,"results":"13","hashOfConfig":"9"},{"size":29300,"mtime":1611884526682,"results":"14","hashOfConfig":"9"},{"size":5181,"mtime":1611884042349,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"ks2wau",{"filePath":"19","messages":"20","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"18"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"18"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"18"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"/Users/evgeny/group-calls-animation/src/index.js",[],["35","36"],"/Users/evgeny/group-calls-animation/src/App.js",["37","38","39"],"import logo from './logo.svg';\nimport React from 'react';\nimport Button from './Button';\nimport TopBar, { MUTE_BUTTON_STATE_UNMUTE, MUTE_BUTTON_STATE_MUTE, MUTE_BUTTON_STATE_CONNECTING, MUTE_BUTTON_STATE_MUTED_BY_ADMIN } from './TopBar';\nimport './App.css';\n\nclass App extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.topBarRef = React.createRef();\n        this.buttonRef = React.createRef();\n    }\n\n    componentDidMount() {\n        this.setAmplitude(0.0);\n    }\n\n    setCurrentState = (stateId, animated) => {\n        const { current: topBar } = this.topBarRef;\n        const { current: button } = this.buttonRef;\n\n        topBar.setCurrentState(stateId, animated);\n        button.updateMuteButton(stateId, animated);\n    };\n\n    setAmplitude(value) {\n        const { current: topBar } = this.topBarRef;\n        const { current: button } = this.buttonRef;\n        if (!topBar) return;\n\n        topBar.setAmplitude(value);\n        button.setAmplitude(value);\n        document.getElementById('text').innerHTML = (Math.round(value * 100) / 100).toFixed(2);\n    }\n\n    handleZeroAmplitude = () => {\n        this.setAmplitude(0.0);\n    };\n\n    handleHalfAmplitude = () => {\n        this.setAmplitude(0.5);\n    };\n\n    handleFullAmplitude = () => {\n        this.setAmplitude(1.0);\n    };\n\n    handleMicrophone = async () => {\n\n        if (this.stream) {\n            console.log('stop mic');\n            this.stream.getAudioTracks().forEach(x => {\n                x.stop();\n            });\n            this.microphone.disconnect();\n            this.analyser.disconnect();\n            this.javascriptNode.disconnect();\n\n            this.stream = null;\n            this.microphone = null;\n            this.analyser = null\n            this.javascriptNode = null;\n            return;\n        }\n\n        console.log('start mic');\n        const stream = await navigator.mediaDevices.getUserMedia ({ audio: true, video: false });\n        this.stream = stream;\n        stream.getTracks().forEach(x => {\n            x.onmute = x => {\n\n            };\n            x.onunmute = x => {\n            };\n\n            x.enabled = true;\n        });\n\n        const audioContext = new AudioContext();\n        const analyser = audioContext.createAnalyser();\n        this.analyser = analyser;\n        const microphone = audioContext.createMediaStreamSource(stream);\n        this.microphone = microphone;\n        const javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);\n        this.javascriptNode = javascriptNode;\n\n        analyser.smoothingTimeConstant = 0.8;\n        analyser.fftSize = 1024;\n\n        microphone.connect(analyser);\n        analyser.connect(javascriptNode);\n        javascriptNode.connect(audioContext.destination);\n        javascriptNode.onaudioprocess = event =>  {\n            const array = new Uint8Array(analyser.frequencyBinCount);\n            analyser.getByteFrequencyData(array);\n\n            const length = array.length;\n            let total = 0;\n            let total2 = 0;\n            for (let i = 0; i < length; i++) {\n                total += array[i] * array[i];\n                total2 += Math.abs(array[i]);\n            }\n\n            const rms = Math.sqrt(total / length) / 255;\n            const average = total2 / length / 255;\n            const first = array[0] / 255;\n\n            let value = rms * 2;\n            value = Math.min(1, value);\n\n            // console.log('', rms, average, value);\n\n            this.setAmplitude(value);\n        }\n    };\n\n    handleUnmuted = () => {\n        this.setCurrentState(MUTE_BUTTON_STATE_UNMUTE, true);\n    }\n\n    handleMuted = () => {\n        this.setCurrentState(MUTE_BUTTON_STATE_MUTE, true);\n    }\n\n    handleMutedByAdmin = () => {\n        this.setCurrentState(MUTE_BUTTON_STATE_MUTED_BY_ADMIN, true);\n    }\n\n    handleConnecting = () => {\n        this.setCurrentState(MUTE_BUTTON_STATE_CONNECTING, true);\n    }\n\n    render() {\n        return (\n            <div className='App'>\n                <TopBar ref={this.topBarRef}/>\n                <Button ref={this.buttonRef}/>\n                <div className='panel'>\n                    <button onClick={this.handleZeroAmplitude}>0.0</button>\n                    <button onClick={this.handleHalfAmplitude}>0.5</button>\n                    <button onClick={this.handleFullAmplitude}>1.0</button>\n                    <button onClick={this.handleUnmuted}>unmute</button>\n                    <button onClick={this.handleMuted}>mute</button>\n                    <button onClick={this.handleMutedByAdmin}>mute by admin</button>\n                    <button onClick={this.handleConnecting}>connecting</button>\n                    <button onClick={this.handleMicrophone}>mic</button>\n                    <div id='text'/>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","/Users/evgeny/group-calls-animation/src/reportWebVitals.js",[],"/Users/evgeny/group-calls-animation/src/LineBlobDrawable.js",[],["40","41"],"/Users/evgeny/group-calls-animation/src/TopBar.js",["42","43","44"],"import React from 'react';\nimport PropTypes from 'prop-types';\nimport LineBlobDrawable from './LineBlobDrawable';\n\nexport const MUTE_BUTTON_STATE_UNMUTE = 0;\nexport const MUTE_BUTTON_STATE_MUTE = 1;\nexport const MUTE_BUTTON_STATE_CONNECTING = 2;\nexport const MUTE_BUTTON_STATE_MUTED_BY_ADMIN = 3;\n\nexport class WeavingState {\n    constructor(stateId) {\n        this.stateId = stateId;\n        this.shader = (ctx, left, top, right, bottom) => { };\n        this.createGradient(stateId);\n    }\n\n    createGradient(stateId) {\n        this.shader = (ctx, left, top, right, bottom) => {\n            ctx.fillStyle = WeavingState.getGradientFromType(ctx, stateId, left, top, right, bottom);\n        };\n    }\n\n    // Android colors\n    static getGradientFromType(ctx, type, x0, y0, x1, y1) {\n        const gradient = ctx.createLinearGradient(x0, y0, x1, y1);\n        if (type === MUTE_BUTTON_STATE_MUTED_BY_ADMIN) {\n            gradient.addColorStop(0, '#57A4FE');\n            gradient.addColorStop(.6, '#766EE9');\n            gradient.addColorStop(1, '#F05459');\n        } else if (type === MUTE_BUTTON_STATE_UNMUTE) {\n            gradient.addColorStop(0, '#00B1C0');\n            gradient.addColorStop(1, '#52CE5D');\n        } else if (type === MUTE_BUTTON_STATE_MUTE) {\n            gradient.addColorStop(0, '#2BCEFF');\n            gradient.addColorStop(1, '#0976E3');\n        } else {\n            gradient.addColorStop(0, '#8599aa');\n            gradient.addColorStop(1, '#8599aa');\n        }\n\n        return gradient;\n    }\n\n    update(height, width, dt, amplitude) {\n        // TODO: move gradient here\n    }\n}\n\nclass TopBar extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.focused = true;\n        this.resizing = false;\n        this.lastUpdateTime = new Date();\n        this.amplitude = 0;\n        this.amplitude2 = 0;\n\n        this.states = [\n            new WeavingState(MUTE_BUTTON_STATE_UNMUTE),\n            new WeavingState(MUTE_BUTTON_STATE_MUTE),\n            new WeavingState(MUTE_BUTTON_STATE_CONNECTING),\n            new WeavingState(MUTE_BUTTON_STATE_MUTED_BY_ADMIN),\n        ];\n        this.prevState = null;\n        this.currentState = this.states[MUTE_BUTTON_STATE_MUTED_BY_ADMIN];\n        this.progressToState = 1.0;\n\n        this.scale = window.devicePixelRatio;\n        this.left = 0 * this.scale;\n        this.top = 20 * this.scale;\n        this.right = 1260 * this.scale;\n        this.bottom = 63 * this.scale;\n    }\n\n    componentDidMount() {\n        window.addEventListener('blur', this.handleBlur);\n        window.addEventListener('focus', this.handleFocus);\n        window.addEventListener('resize', this.handleResize);\n        this.media = window.matchMedia('screen and (min-resolution: 2dppx)');\n        this.media.addEventListener('change', this.handleDevicePixelRatioChanged);\n\n        const topBar = document.getElementById('top-bar');\n        this.right = topBar.offsetWidth * this.scale;\n        this.forceUpdate();\n\n        this.canvas = document.getElementById('canvas');\n        this.lbd = new LineBlobDrawable(3);\n        this.lbd1 = new LineBlobDrawable(7);\n        this.lbd2 = new LineBlobDrawable(8);\n        this.setAmplitude(this.amplitude);\n\n        this.draw();\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('blur', this.handleBlur);\n        window.removeEventListener('focus', this.handleFocus);\n        window.removeEventListener('resize', this.handleResize);\n        this.media.addEventListener('change', this.handleDevicePixelRatioChanged);\n    }\n\n    handleDevicePixelRatioChanged = e => {\n        this.scale = window.devicePixelRatio;\n        this.left = 0 * this.scale;\n        this.top = 20 * this.scale;\n        this.bottom = 63 * this.scale;\n        const topBar = document.getElementById('top-bar');\n        this.right = topBar.offsetWidth * this.scale;\n        this.forceUpdate();\n    }\n\n\n    handleResize = () => {\n        if (this.resizeHandler) {\n            clearTimeout(this.resizeHandler);\n            this.resizeHandler = null;\n        }\n\n        this.resizing = true;\n        this.resizeCanvas();\n        this.resizeHandler = setTimeout(() => {\n            this.resizing = false;\n            this.invokeDraw();\n        }, 250);\n    }\n\n    resizeCanvas() {\n        const topBar = document.getElementById('top-bar');\n\n        this.scale = window.devicePixelRatio;\n        this.right = topBar.offsetWidth * this.scale;\n\n        this.forceUpdate();\n        this.invokeDraw();\n    }\n\n    handleFocus = () => {\n        this.focused = true;\n        this.invokeDraw();\n    }\n\n    handleBlur = () => {\n        this.focused = false;\n    }\n\n    invokeDraw = () => {\n        if (this.raf) return;\n\n        this.draw();\n    }\n\n    draw = (force = false) => {\n        this.raf = null;\n        const { lbd, lbd1, lbd2, scale, left, top, right, bottom, currentState, previousState, focused, resizing } = this;\n        if (!focused && !resizing) {\n            return;\n        }\n\n        // console.log('draw', [focused, resizing]);\n\n        const newTime = new Date();\n        let dt = (newTime - this.lastUpdateTime);\n        if (dt > 20) {\n            dt = 17;\n        }\n\n        // console.log('draw start', this.amplitude, this.animateToAmplitude);\n        if (this.animateToAmplitude !== this.amplitude) {\n            this.amplitude += this.animateAmplitudeDiff * dt;\n            if (this.animateAmplitudeDiff > 0) {\n                if (this.amplitude > this.animateToAmplitude) {\n                    this.amplitude = this.animateToAmplitude;\n                }\n            } else {\n                if (this.amplitude < this.animateToAmplitude) {\n                    this.amplitude = this.animateToAmplitude;\n                }\n            }\n        }\n\n        if (this.animateToAmplitude !== this.amplitude2) {\n            this.amplitude2 += this.animateAmplitudeDiff2 * dt;\n            if (this.animateAmplitudeDiff2 > 0) {\n                if (this.amplitude2 > this.animateToAmplitude) {\n                    this.amplitude2 = this.animateToAmplitude;\n                }\n            } else {\n                if (this.amplitude2 < this.animateToAmplitude) {\n                    this.amplitude2 = this.animateToAmplitude;\n                }\n            }\n        }\n\n        if (previousState) {\n            this.progressToState += dt / 250;\n            if (this.progressToState > 1) {\n                this.progressToState = 1;\n                this.previousState = null;\n            }\n        }\n\n        const top1 = 6 * this.amplitude2 * scale;\n        const top2 = 6 * this.amplitude2 * scale;\n\n        const ctx = this.canvas.getContext('2d');\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        lbd.minRadius = 0;\n        lbd.maxRadius = (2 + 2 * this.amplitude) * scale;\n        lbd1.minRadius = 0;\n        lbd1.maxRadius = (3 + 9 * this.amplitude) * scale;\n        lbd2.minRadius = 0;\n        lbd2.maxRadius = (3 + 9 * this.amplitude) * scale;\n\n        lbd.update(this.amplitude, 0.3);\n        lbd1.update(this.amplitude, 0.7);\n        lbd2.update(this.amplitude, 0.7);\n\n        for (let i = 0; i < 2; i++) {\n            if (i === 0 && !previousState) {\n                continue;\n            }\n\n            let alpha = 1;\n            let state = null;\n            if (i === 0) {\n                alpha = 1 - this.progressToState;\n                state = previousState;\n                // previousState.setToPaint(paint);\n            } else {\n                alpha = previousState ? this.progressToState : 1;\n                currentState.update(bottom - top, right - left, dt, this.amplitude);\n                state = currentState;\n                // currentState.setToPaint(paint);\n            }\n\n            const paint1 = ctx => {\n                ctx.globalAlpha = 0.3 * alpha;\n                state.shader(ctx, left, top, right, bottom);\n            };\n            const paint = ctx => {\n                ctx.globalAlpha = i === 0? 1 : alpha;\n                state.shader(ctx, left, top, right, bottom);\n            };\n\n            lbd1.draw(left, top - top1, right, bottom, this.canvas, paint1,  top, 1.0);\n            lbd2.draw(left, top - top2, right, bottom, this.canvas, paint1,  top, 1.0);\n            lbd.draw(left, top, right, bottom, this.canvas, paint, top, 1.0);\n        }\n\n        if (!force) {\n            this.raf = requestAnimationFrame(() => this.draw());\n        }\n    };\n\n    setCurrentState = (stateId, animated) => {\n        const { currentState, states } = this;\n\n        if (currentState && currentState.id === stateId) {\n            return;\n        }\n\n        this.previousState = animated ? currentState : null;\n        this.currentState = states[stateId];\n        this.progressToState = this.previousState ? 0.0 : 1.0;\n    };\n\n    setAmplitude(value) {\n        this.animateToAmplitude = value;\n        this.animateAmplitudeDiff = (value - this.amplitude) / 250;\n        this.animateAmplitudeDiff2 = (value - this.amplitude) / 120;\n    }\n\n    render() {\n        const { left, right, top, bottom, scale } = this;\n\n        return(\n            <div id='top-bar' className='top-bar'>\n                <canvas id='canvas' width={right} height={bottom} style={{ width: right / scale, height: bottom / scale }}/>\n            </div>\n        );\n    }\n}\n\nTopBar.propTypes = {};\n\nexport default TopBar;","/Users/evgeny/group-calls-animation/src/Button.js",["45","46","47","48","49"],"import React from 'react';\nimport PropTypes from 'prop-types';\nimport BlobDrawable, {\n    AMPLITUDE_SPEED,\n    FORM_BIG_MAX,\n    FORM_SMALL_MAX, LIGHT_GRADIENT_SIZE,\n    SCALE_BIG,\n    SCALE_BIG_MIN,\n    SCALE_SMALL,\n    SCALE_SMALL_MIN\n} from './BlobDrawable';\nimport {\n    MUTE_BUTTON_STATE_CONNECTING,\n    MUTE_BUTTON_STATE_MUTE,\n    MUTE_BUTTON_STATE_MUTED_BY_ADMIN,\n    MUTE_BUTTON_STATE_UNMUTE\n} from './TopBar';\n\n/// https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/view/animation/OvershootInterpolator.java\nclass OvershootInterpolator {\n    constructor(tension) {\n        this.mTension = tension;\n    }\n\n    getInterpolation(t) {\n        // _o(t) = t * t * ((tension + 1) * t + tension)\n        // o(t) = _o(t - 1) + 1\n        t -= 1.0;\n        return t * t * ((this.mTension + 1) * t + this.mTension) + 1.0;\n    }\n}\n\n// https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/view/animation/DecelerateInterpolator.java\nclass DecelerateInterpolator {\n    constructor(factor) {\n        this.mFactor = factor || 1.0;\n    }\n\n    getInterpolation(input) {\n        let result;\n        if (this.mFactor === 1.0) {\n            result = 1.0 - (1.0 - input) * (1.0 - input);\n        } else {\n            result = 1.0 - Math.pow((1.0 - input), 2 * this.mFactor);\n        }\n        return result;\n    }\n}\n\n/// https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/view/animation/AccelerateInterpolator.java\nclass AccelerateInterpolator {\n    constructor(factor) {\n        this.mFactor = factor || 1.0;\n        this.mDoubleFactor = 2 * this.mFactor;\n    }\n\n    getInterpolation(input) {\n        if (this.mFactor === 1.0) {\n            return input * input;\n        }\n\n        return Math.pow(input, this.mDoubleFactor);\n    }\n}\n\nclass WeavingState {\n    constructor(stateId) {\n        this.stateId = stateId;\n        this.shader = (ctx, left, top, right, bottom) => { };\n        this.createGradient(stateId);\n    }\n\n    createGradient(stateId) {\n        this.shader = (ctx, left, top, right, bottom) => {\n            ctx.fillStyle = WeavingState.getGradientFromType(ctx, stateId, left, top, right, bottom);\n        };\n    }\n\n    update(top, left, size, dt) {\n        // TODO: move gradient here\n    }\n\n    // Android colors\n    static getGradientFromType(ctx, type, left, top, right, bottom) {\n        if (type === MUTE_BUTTON_STATE_MUTED_BY_ADMIN) {\n            const gradient = ctx.createLinearGradient(0, 100, 100, 0);\n\n            gradient.addColorStop(0, '#57A4FE');\n            gradient.addColorStop(.3, '#766EE9');\n            gradient.addColorStop(1, '#F05459');\n\n            return gradient;\n        } else if (type === MUTE_BUTTON_STATE_UNMUTE) {\n            const gradient=ctx.createRadialGradient(0,50,0,0,50,200);\n\n            gradient.addColorStop(0, '#77E55C');\n            gradient.addColorStop(1, '#56C7FE');\n\n            return gradient;\n        } else if (type === MUTE_BUTTON_STATE_MUTE) {\n            const gradient = ctx.createRadialGradient(0,50,0,0,50,200);\n\n            gradient.addColorStop(0, '#66D4FB');\n            gradient.addColorStop(1, '#539EF8');\n\n            return gradient;\n        } else {\n            const gradient = ctx.createLinearGradient(0, 400, 400, 0);\n\n            gradient.addColorStop(0, '#2B333E');\n            gradient.addColorStop(1, '#2B333E');\n\n            return gradient;\n        }\n    }\n}\n\nclass RadialProgressView {\n    constructor() {\n        this.decelerateInterpolator = new DecelerateInterpolator();\n        this.accelerateInterpolator = new AccelerateInterpolator();\n\n        this.lineCap = 'round';\n        this.lineWidth = 3;\n        this.progressColor = '#1C93E3';\n        this.updateProgressPaint();\n\n        this.lastUpdateTime = 0;\n        this.radOffset = 0;\n        this.currentCircleLength = 0;\n        this.risingCircleLength = false;\n        this.currentProgressTime = 0;\n        this.useSelfAlpha = false;\n        this.drawingCircleLength = 0;\n\n        this.rotationTime = 2000;\n        this.risingTime = 500;\n        this.size = 0;\n\n        this.currentProgress = 0;\n        this.progressAnimationStart = 0;\n        this.progressTime = 0;\n        this.animatedProgress = 0;\n        this.circle = false;\n        this.circleProgress = 0;\n        this.noProgress = true;\n    }\n\n    setUseSelfAlpha = value => {\n        this.useSelfAlpha = value;\n    };\n\n    setAlpha = alpha => {\n        console.log('[rpv] setAlpha', alpha);\n    };\n\n    setNoProgress = value => {\n        this.noProgress = value;\n    };\n\n    setProgress = value => {\n        this.currentProgress = value;\n        if (this.animatedProgress > value) {\n            this.animatedProgress = value;\n        }\n\n        this.progressAnimationStart = this.animatedProgress;\n        this.progressTime = 0;\n    };\n\n    updateAnimation = () => {\n        const newTime = new Date();\n        let dt = newTime - this.lastUpdateTime;\n        if (dt > 17) {\n            dt = 17;\n        }\n        this.lastUpdateTime = newTime;\n\n        this.radOffset += 360 * dt / this.rotationTime;\n        let count = Math.trunc(this.radOffset / 360);\n        this.radOffset -= count * 360;\n\n        if (this.circle && this.circleProgress !== 1.0) {\n            this.circleProgress += 16 / 220;\n            if (this.circleProgress > 1.0) {\n                this.circleProgress = 1.0;\n            }\n        } else if (!this.circle && this.circleProgress !== 0.0) {\n            this.circleProgress -= 16 / 400;\n            if (this.circleProgress < 0) {\n                this.circleProgress = 0;\n            }\n        }\n\n        if (this.noProgress) {\n            if (this.circleProgress === 0) {\n                this.currentProgressTime += dt;\n                if (this.currentProgressTime >= this.risingTime) {\n                    this.currentProgressTime = this.risingTime;\n                }\n                if (this.risingCircleLength) {\n                    this.currentCircleLength = 4 + 266 * this.accelerateInterpolator.getInterpolation(this.currentProgressTime / this.risingTime);\n                } else {\n                    this.currentCircleLength = 4 - 270 * (1.0 - this.decelerateInterpolator.getInterpolation(this.currentProgressTime / this.risingTime));\n                }\n\n                if (this.currentProgressTime === this.risingTime) {\n                    if (this.risingCircleLength) {\n                        this.radOffset += 270;\n                        this.currentCircleLength = -266;\n                    }\n\n                    this.risingCircleLength = !this.risingCircleLength;\n                    this.currentProgressTime = 0;\n                }\n            } else {\n                if (this.risingCircleLength) {\n                    const old = this.currentCircleLength;\n                    this.currentCircleLength = 4 + 266 * this.accelerateInterpolator.getInterpolation(this.currentProgressTime / this.risingTime);\n                    this.currentCircleLength += 360 * this.circleProgress;\n                    const dx = old - this.currentCircleLength;\n                    if (dx > 0) {\n                        this.radOffset += old - this.currentCircleLength;\n                    }\n                } else {\n                    const old = this.currentCircleLength;\n                    this.currentCircleLength = 4 - 270 * (1.0 - this.decelerateInterpolator.getInterpolation(this.currentProgressTime / this.risingTime));\n                    this.currentCircleLength -= 364 * this.circleProgress;\n                    const dx = old - this.currentCircleLength;\n                    if (dx > 0) {\n                        this.radOffset += old - this.currentCircleLength;\n                    }\n                }\n            }\n        }\n        else {\n            let progressDiff = this.currentProgress - this.progressAnimationStart;\n            if (progressDiff > 0) {\n                progressDiff += dt;\n                if (this.progressTime >= 200) {\n                    this.animatedProgress = this.progressAnimationStart = this.currentProgress;\n                    this.progressTime = 0;\n                } else {\n                    this.animatedProgress = this.progressAnimationStart + progressDiff * this.decelerateInterpolator.getInterpolation(this.progressTime / 200);\n                }\n            }\n            this.currentCircleLength = Math.max(4, 360 * this.animatedProgress);\n        }\n    };\n\n    setSize = size => {\n        this.size = size;\n    };\n\n    setStrokeWidth = value => {\n        this.lineWidth = value;\n        this.updateProgressPaint();\n    };\n\n    setProgressColor = color => {\n        this.progressColor = color;\n        this.updateProgressPaint();\n    };\n\n    updateProgressPaint() {\n        this.progressPaint = ctx => {\n            if (this.lineCap) {\n                ctx.lineCap = this.lineCap;\n            }\n            if (this.lineWidth) {\n                ctx.lineWidth = this.lineWidth;\n            }\n            if (this.progressColor) {\n                ctx.strokeStyle = this.progressColor;\n            }\n        };\n    }\n\n    toCircle = (toCircle, animated) => {\n        this.circle = toCircle;\n        if (!animated) {\n            this.circleProgress = this.circle ? 1.0 : 0.0;\n        }\n    }\n\n    draw = (canvas, cx, cy, scale = 1) => {\n        this.circleRect = { x0: cx - this.size / 2, y0: cy - this.size / 2, x1: cx + this.size / 2, y1: cy + this.size / 2 };\n        const ctx = canvas.getContext('2d');\n        if (ctx) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(cx, cy);\n            ctx.scale(scale, scale);\n            ctx.beginPath();\n            if (!this.risingCircleLength) {\n                if ((this.radOffset + this.currentCircleLength) > this.radOffset) {\n                    this.currentCircleLength = 0;\n                }\n            }\n\n            const radStart = this.radOffset * Math.PI / 180;\n            this.drawingCircleLength = this.currentCircleLength;\n            const radLength = this.drawingCircleLength * Math.PI / 180;\n\n\n            ctx.arc(0, 0, this.size / 2, radStart, radStart + radLength, !this.risingCircleLength);\n            this.progressPaint(ctx);\n            ctx.stroke();\n            ctx.restore();\n\n            this.updateAnimation();\n        }\n    }\n\n    isCircle = () => {\n        return Math.abs(this.drawingCircleLength) >= 360;\n    }\n}\n\nclass Button extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.invalidateColors = true;\n        this.radialProgressView = new RadialProgressView();\n        this.radialProgressView.setSize(110);\n        this.radialProgressView.setStrokeWidth(4);\n        this.radialProgressView.setProgressColor('#28BAFF');\n\n        this.radialPaint = ctx => { };\n        this.paint = ctx => { };\n        this.paintTmp = ctx => { };\n        this.lastUpdateTime = new Date();\n        this.amplitude = 0.0;\n\n        this.states = [\n            new WeavingState(MUTE_BUTTON_STATE_UNMUTE),\n            new WeavingState(MUTE_BUTTON_STATE_MUTE),\n            new WeavingState(MUTE_BUTTON_STATE_CONNECTING),\n            new WeavingState(MUTE_BUTTON_STATE_MUTED_BY_ADMIN),\n        ];\n        this.switchProgress = 1;\n        this.muteButtonState = MUTE_BUTTON_STATE_MUTED_BY_ADMIN;\n        this.prevState = null;\n        this.currentState = this.states[this.muteButtonState];\n        this.progressToState = 1.0;\n\n        this.showLightingProgress = 1.0;\n        this.showWavesProgress = 1.0;\n        this.overshootInterpolator = new OvershootInterpolator(1.5);\n        this.colorsTmp = new Array(3);\n\n        this.scale = window.devicePixelRatio;\n        this.left = 0 * this.scale;\n        this.top = 0 * this.scale;\n        this.right = 400 * this.scale;\n        this.bottom = 400 * this.scale;\n    }\n\n    componentDidMount() {\n        this.canvas = document.getElementById('button-canvas');\n        this.tinyWaveDrawable = new BlobDrawable(9);\n        this.bigWaveDrawable = new BlobDrawable(12);\n\n        this.tinyWaveDrawable.minRadius = 62;\n        this.tinyWaveDrawable.maxRadius = 72;\n        this.tinyWaveDrawable.generateInitBlob();\n\n        this.bigWaveDrawable.minRadius = 65;\n        this.bigWaveDrawable.maxRadius = 75;\n        this.bigWaveDrawable.generateInitBlob();\n\n        const color = '#66D4FB';\n        this.radialGradient = ctx => {\n            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 160);\n            gradient.addColorStop(0, color + '32');\n            gradient.addColorStop(1, color + '00');\n\n            ctx.fillStyle = gradient;\n        };\n        this.radialPaint = this.radialGradient;\n\n        this.setAmplitude(this.amplitude);\n\n        // console.log('[button] componentDidMount draw');\n        this.draw();\n    }\n\n    fillColors(stateId, colorsToSet) {\n        if (stateId === MUTE_BUTTON_STATE_UNMUTE) {\n            colorsToSet[0] = '#66D4FB';\n            colorsToSet[1] = '';\n            colorsToSet[2] = '';\n        } else if (stateId === MUTE_BUTTON_STATE_MUTE) {\n            colorsToSet[0] = '#7DDCAA';\n            colorsToSet[1] = '';\n            colorsToSet[2] = '';\n        } else if (stateId === MUTE_BUTTON_STATE_MUTED_BY_ADMIN) {\n            colorsToSet[0] = '#766EE9';\n            colorsToSet[1] = '';\n            colorsToSet[2] = '';\n        } else {\n            colorsToSet[0] = '#1C2229';\n            colorsToSet[1] = '';\n            colorsToSet[2] = '';\n        }\n    }\n\n    strToHex(n) {\n        let s = n.toString(16);\n        if (s.length === 1) {\n            s = '0' + s;\n        }\n        return s;\n    }\n\n    blendARGB(color1, color2, ratio) {\n        if (color1.length <= 7) {\n            color1 += 'FF';\n        }\n        if (color2.length <= 7) {\n            color2 += 'FF';\n        }\n        const c1 = {\n            r: parseInt(color1.substr(1, 2), 16),\n            g: parseInt(color1.substr(3, 2), 16),\n            b: parseInt(color1.substr(5, 2), 16),\n            a: parseInt(color1.substr(7, 2), 16),\n        };\n        const c2 = {\n            r: parseInt(color2.substr(1, 2), 16),\n            g: parseInt(color2.substr(3, 2), 16),\n            b: parseInt(color2.substr(5, 2), 16),\n            a: parseInt(color2.substr(7, 2), 16),\n        };\n\n        const inverseRatio = 1 - ratio;\n        const a = Math.trunc(c1.a * inverseRatio + c2.a * ratio) % 256;\n        const r = Math.trunc(c1.r * inverseRatio + c2.r * ratio) % 256;\n        const g = Math.trunc(c1.g * inverseRatio + c2.g * ratio) % 256;\n        const b = Math.trunc(c1.b * inverseRatio + c2.b * ratio) % 256;\n\n        return `#${this.strToHex(r)}${this.strToHex(g)}${this.strToHex(b)}`;\n    }\n\n    draw = (force = false) => {\n        // console.log('[button] draw');\n        const { currentState, prevState, left, top, right, bottom } = this;\n\n        const newTime = new Date();\n        let dt = (newTime - this.lastUpdateTime);\n        if (dt > 20) {\n            dt = 17;\n        }\n\n        this.tinyWaveDrawable.minRadius = 62;\n        this.tinyWaveDrawable.maxRadius = 62 + 20 * FORM_SMALL_MAX;\n\n        this.bigWaveDrawable.minRadius = 65;\n        this.bigWaveDrawable.maxRadius = 65 + 20 * FORM_BIG_MAX;\n\n        if (this.animateToAmplitude !== this.amplitude) {\n            this.amplitude = this.amplitude + this.animateAmplitudeDiff * dt;\n            if (this.animateAmplitudeDiff > 0) {\n                if (this.amplitude > this.animateToAmplitude) {\n                    this.amplitude = this.animateToAmplitude;\n                }\n            } else {\n                if (this.amplitude < this.animateToAmplitude) {\n                    this.amplitude = this.animateToAmplitude;\n                }\n            }\n        }\n\n        let canSwitchProgress = true;\n        if (prevState && prevState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n            this.radialProgressView.toCircle(true, true);\n            if (!this.radialProgressView.isCircle()) {\n                canSwitchProgress = false;\n            }\n        } else if (prevState && currentState && currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n            this.radialProgressView.toCircle(true, false);\n        }\n\n        if (canSwitchProgress) {\n            if (this.switchProgress !== 1) {\n                if (prevState && prevState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                    this.switchProgress += dt / 100;\n                } else {\n                    this.switchProgress += dt / 180;\n                }\n\n                if (this.switchProgress >= 1.0) {\n                    this.switchProgress = 1.0;\n                    this.prevState = null;\n                    if (currentState && currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                        this.radialProgressView.toCircle(false, true);\n                    }\n                }\n                this.invalidateColors = true;\n            }\n\n            if (this.invalidateColors && currentState) {\n                this.invalidateColors = false;\n                let lightingColor;\n                if (prevState) {\n                    this.fillColors(prevState.stateId, this.colorsTmp);\n                    const oldLight = this.colorsTmp[0];\n                    this.fillColors(currentState.stateId, this.colorsTmp);\n                    const newLight = this.colorsTmp[0];\n                    lightingColor = this.blendARGB(oldLight, newLight, this.switchProgress);\n                } else {\n                    this.fillColors(currentState.stateId, this.colorsTmp);\n                    lightingColor = this.colorsTmp[0];\n                }\n                if (this.currentLightColor !== lightingColor) {\n                    this.radialGradient = ctx => {\n                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 100);\n\n                        gradient.addColorStop(0, lightingColor + '3C');\n                        gradient.addColorStop(1, lightingColor + '00');\n\n                        ctx.fillStyle = gradient;\n                    };\n                    this.currentLightColor = lightingColor;\n                }\n            }\n\n            let showWaves = false;\n            let showLighting = false;\n            if (currentState) {\n                showWaves = currentState.stateId === MUTE_BUTTON_STATE_MUTE || currentState.stateId === MUTE_BUTTON_STATE_UNMUTE;\n                showLighting = currentState.stateId !== MUTE_BUTTON_STATE_CONNECTING;\n            }\n\n            if (prevState && currentState && currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                this.showWavesProgress -= dt / 180;\n                if (this.showWavesProgress < 0) {\n                    this.showWavesProgress = 0;\n                }\n            } else {\n                if (showWaves && this.showWavesProgress !== 1) {\n                    this.showWavesProgress += dt / 350;\n                    if (this.showWavesProgress > 1) {\n                        this.showWavesProgress = 1;\n                    }\n                } else if (!showWaves && this.showWavesProgress !== 0) {\n                    this.showWavesProgress -= dt / 350;\n                    if (this.showWavesProgress < 0) {\n                        this.showWavesProgress = 0;\n                    }\n                }\n            }\n\n            if (showLighting && this.showLightingProgress !== 1) {\n                this.showLightingProgress += dt / 350;\n                if (this.showLightingProgress > 1) {\n                    this.showLightingProgress = 1;\n                }\n            } else if (!showLighting && this.showLightingProgress !== 0) {\n                this.showLightingProgress -= dt / 350;\n                if (this.showLightingProgress < 0) {\n                    this.showLightingProgress = 0;\n                }\n            }\n        }\n\n        let showWavesProgressInterpolated = this.overshootInterpolator.getInterpolation(this.showWavesProgress);\n        showWavesProgressInterpolated = 0.4 + 0.6 * showWavesProgressInterpolated;\n\n        this.bigWaveDrawable.update(this.amplitude, 1.0);\n        this.tinyWaveDrawable.update(this.amplitude, 1.0);\n\n        const ctx = this.canvas.getContext('2d');\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.resetTransform();\n\n        const cx = this.canvas.width / 2;\n        const cy = this.canvas.height / 2;\n\n        if (prevState && currentState && (currentState.stateId === MUTE_BUTTON_STATE_CONNECTING || prevState.stateId === MUTE_BUTTON_STATE_CONNECTING)) {\n            let progress;\n            if (currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                progress = this.switchProgress;\n                this.paint = prevState.shader;\n            } else {\n                progress = 1.0 - this.switchProgress;\n                this.paint = currentState.shader;\n            }\n\n            this.paintTmp = ctx => {\n                ctx.fillStyle = '#2B333E';\n            }\n\n            let paint = ctx => {\n                this.paint(ctx, left, top, right, bottom);\n            };\n\n            ctx.globalAlpha = 1.0;\n            let scale = SCALE_BIG_MIN + SCALE_BIG * this.amplitude * 0.5;\n            const scaleLight = 0.7 + LIGHT_GRADIENT_SIZE;\n            this.drawCircle(ctx, cx, cy, scaleLight * scale * this.showLightingProgress * this.scale, 160, this.radialGradient);\n\n            ctx.globalAlpha = 0.3;\n            // big wave\n            ctx.save();\n            scale = SCALE_BIG_MIN + SCALE_BIG * this.amplitude;\n            ctx.translate(cx, cy);\n            ctx.scale(scale * showWavesProgressInterpolated * this.scale, scale * showWavesProgressInterpolated * this.scale);\n            this.bigWaveDrawable.draw(0, 0 ,this.canvas, paint);\n            ctx.restore();\n\n            // small wave\n            ctx.save();\n            scale = SCALE_SMALL_MIN + SCALE_SMALL * this.amplitude;\n            ctx.translate(cx, cy);\n            ctx.scale(scale * showWavesProgressInterpolated * this.scale, scale * showWavesProgressInterpolated * this.scale);\n            this.tinyWaveDrawable.draw(0, 0, this.canvas, paint);\n            ctx.restore();\n\n            ctx.globalAlpha = 1.0;\n            if (canSwitchProgress) {\n                this.drawCircle(ctx, cx, cy, this.scale, 57, paint);\n                paint = ctx => {\n                    ctx.fillStyle = '#28BAFF';\n                };\n                if (progress !== 0) {\n                    ctx.globalAlpha = progress;\n                    this.drawCircle(ctx, cx, cy, this.scale, 57, paint);\n                }\n            }\n            ctx.globalAlpha = 1.0;\n            this.drawCircle(ctx, cx, cy, 55 * progress * this.scale, 1, this.paintTmp);\n            if  (!canSwitchProgress) {\n                this.radialProgressView.draw(this.canvas, cx, cy, this.scale);\n            }\n            ctx.restore();\n        } else {\n            for (let i = 0; i < 2; i++) {\n                let alpha = 0;\n                let buttonRadius = 57;\n                let paint = null;\n                if (i === 0 && prevState) {\n                    paint = prevState.shader;\n                    alpha = 1 - this.switchProgress;\n                    if (prevState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                        buttonRadius -= alpha * 2;\n                    }\n                } else if (i === 1) {\n                    paint = currentState.shader;\n                    alpha = this.switchProgress;\n                    if (currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                        buttonRadius -= alpha * 2;\n                    }\n                } else {\n                    continue;\n                }\n\n                if (!paint) {\n                    paint = ctx => {\n                        ctx.fillStyle = '#2B333E';\n                    };\n                }\n\n                ctx.globalAlpha = 1.0;\n                let scale = SCALE_BIG_MIN + SCALE_BIG * this.amplitude * 0.5;\n                if (i === 1) {\n                    const scaleLight = 0.7 + LIGHT_GRADIENT_SIZE;\n                    this.drawCircle(ctx, cx, cy, scaleLight * scale * this.showLightingProgress * this.scale, 160, this.radialGradient);\n                }\n\n                ctx.globalAlpha = 0.3 * alpha;\n                // big wave\n                ctx.save();\n                scale = SCALE_BIG_MIN + SCALE_BIG * this.amplitude;\n                ctx.translate(cx, cy);\n                ctx.scale(scale * showWavesProgressInterpolated * this.scale, scale * showWavesProgressInterpolated * this.scale);\n                this.bigWaveDrawable.draw(0, 0 ,this.canvas, paint);\n                ctx.restore();\n\n                // small wave\n                ctx.save();\n                scale = SCALE_SMALL_MIN + SCALE_SMALL * this.amplitude;\n                ctx.translate(cx, cy);\n                ctx.scale(scale * showWavesProgressInterpolated * this.scale, scale * showWavesProgressInterpolated * this.scale);\n                this.tinyWaveDrawable.draw(0, 0, this.canvas, paint);\n                ctx.restore();\n            }\n\n            // button\n            for (let i = 0; i < 2; i++) {\n                let alpha = 0;\n                let buttonRadius = 57;\n                let paint = null;\n                if (i === 0 && prevState) {\n                    paint = prevState.shader;\n                    alpha = 1 - this.switchProgress;\n                    if (prevState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                        buttonRadius -= alpha * 2;\n                    }\n                } else if (i === 1) {\n                    paint = currentState.shader;\n                    alpha = this.switchProgress;\n                    if (currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                        buttonRadius -= alpha * 2;\n                    }\n                } else {\n                    continue;\n                }\n\n                if (!paint) {\n                    paint = ctx => {\n                        ctx.fillStyle = '#2B333E';\n                    };\n                }\n\n                if (i === 0) {\n                    ctx.globalAlpha = 1.0;\n                } else {\n                    ctx.globalAlpha = alpha;\n                }\n                this.drawCircle(ctx, cx, cy, this.scale, buttonRadius, paint);\n\n                if (i === 1 && currentState.stateId === MUTE_BUTTON_STATE_CONNECTING) {\n                    this.radialProgressView.draw(this.canvas, cx, cy, this.scale);\n                }\n            }\n        }\n\n        if (!force) {\n            this.raf = requestAnimationFrame(() => this.draw());\n        }\n    };\n\n    drawCircle(ctx, cx, cy, scale, radius, paint) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(cx, cy);\n        ctx.scale(scale, scale);\n        ctx.arc(0, 0, radius, 0, 2 * Math.PI, false);\n        ctx.closePath();\n        paint && paint(ctx);\n        ctx.fill();\n        ctx.restore();\n    }\n\n    setCurrentState = (stateId, animated) => {\n        const { currentState, states } = this;\n\n        if (currentState && currentState.id === stateId) {\n            return;\n        }\n\n        this.previousState = animated ? currentState : null;\n        this.currentState = states[stateId];\n        this.progressToState = this.previousState ? 0.0 : 1.0;\n    };\n\n    updateMuteButton = (stateId, animated) => {\n        const { muteButtonState } = this;\n        if (muteButtonState === stateId && animated) {\n            return;\n        }\n\n        // TODO: add text animation\n\n        if (animated) {\n            this.muteButtonState = stateId;\n        } else {\n            this.muteButtonState = stateId;\n        }\n        this.updateMuteButtonState(animated);\n    }\n\n    updateMuteButtonState (animated) {\n        const { states, currentState, muteButtonState } = this;\n\n        if (states[muteButtonState] !== currentState) {\n            this.prevState = currentState;\n            this.currentState = states[muteButtonState];\n            if (!this.prevState || !animated) {\n                this.switchProgress = 1.0;\n                this.prevState = null;\n            } else {\n                this.switchProgress = 0.0;\n            }\n        }\n\n        if (!animated) {\n            let showWaves = false;\n            let showLighting = false;\n            if (currentState) {\n                showWaves = currentState.stateId === MUTE_BUTTON_STATE_MUTE || currentState.stateId === MUTE_BUTTON_STATE_UNMUTE;\n                showLighting = currentState.stateId === MUTE_BUTTON_STATE_CONNECTING;\n            }\n            this.showWavesProgress = showWaves ? 1.0 : 0.0;\n            this.showLightingProgress = showLighting ? 1.0 : 0.0;\n        }\n    }\n\n    setAmplitude(value) {\n        this.animateToAmplitude = value;\n        this.animateAmplitudeDiff = (value - this.amplitude) / (100 + 500 * AMPLITUDE_SPEED);\n        // console.log('[button] setAmplitude', [this.amplitude, this.animateToAmplitude, this.animateAmplitudeDiff]);\n    }\n\n    render() {\n        const { left, right, top, bottom, scale } = this;\n\n        return (\n            <div id='button' className='button' style={{ background: '#192026' }}>\n                <canvas id='button-canvas' width={right} height={bottom} style={{ width: right / scale, height: bottom / scale }}/>\n            </div>\n        );\n    }\n\n}\n\nButton.propTypes = {};\n\nexport default Button;","/Users/evgeny/group-calls-animation/src/BlobDrawable.js",[],{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","severity":1,"message":"55","line":1,"column":8,"nodeType":"56","messageId":"57","endLine":1,"endColumn":12},{"ruleId":"54","severity":1,"message":"58","line":108,"column":19,"nodeType":"56","messageId":"57","endLine":108,"endColumn":26},{"ruleId":"54","severity":1,"message":"59","line":109,"column":19,"nodeType":"56","messageId":"57","endLine":109,"endColumn":24},{"ruleId":"50","replacedBy":"60"},{"ruleId":"52","replacedBy":"61"},{"ruleId":"54","severity":1,"message":"62","line":2,"column":8,"nodeType":"56","messageId":"57","endLine":2,"endColumn":17},{"ruleId":"54","severity":1,"message":"63","line":276,"column":17,"nodeType":"56","messageId":"57","endLine":276,"endColumn":21},{"ruleId":"54","severity":1,"message":"64","line":276,"column":30,"nodeType":"56","messageId":"57","endLine":276,"endColumn":33},{"ruleId":"54","severity":1,"message":"62","line":2,"column":8,"nodeType":"56","messageId":"57","endLine":2,"endColumn":17},{"ruleId":"54","severity":1,"message":"65","line":439,"column":15,"nodeType":"56","messageId":"57","endLine":439,"endColumn":16},{"ruleId":"54","severity":1,"message":"66","line":654,"column":25,"nodeType":"56","messageId":"57","endLine":654,"endColumn":37},{"ruleId":"54","severity":1,"message":"63","line":809,"column":17,"nodeType":"56","messageId":"57","endLine":809,"endColumn":21},{"ruleId":"54","severity":1,"message":"64","line":809,"column":30,"nodeType":"56","messageId":"57","endLine":809,"endColumn":33},"no-native-reassign",["67"],"no-negated-in-lhs",["68"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'average' is assigned a value but never used.","'first' is assigned a value but never used.",["67"],["68"],"'PropTypes' is defined but never used.","'left' is assigned a value but never used.","'top' is assigned a value but never used.","'a' is assigned a value but never used.","'buttonRadius' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]